{"noir_version":"1.0.0-beta.9+6abff2f16e1c1314ba30708d1cf032a536de3d19","hash":"16266063050494189041","abi":{"parameters":[{"name":"seed","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"seed_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"}],"return_type":null,"error_types":{"4085138339373375158":{"error_kind":"string","string":"seed entropy too low: first 4 bytes are all zero"},"4838613324355834180":{"error_kind":"string","string":"seed hash mismatch: blake2s(seed) != seed_hash"}}},"bytecode":"H4sIAAAAAAAA/9Wa11LbQBSGJRsCpCdAekLvTXLBMr333nsx2EzyNnmP5CLDTB4nz5HLnBOkycH82RuOL3Zn/lnN/8Na3xqOLem4zs24In0Jj11SPJx5VBZ5LvBiwIsDrwx45cB7ALwK4FUCrwp4D4H3CHiPgfcEeE+B9wx4z4H3AngvgVcNvBrg1QLvFfBeA+8N8N4C7x3w3gPvA/A+Au8T8OqAVw+8BuA1Aq8JeM3AawFeK/DagNcOvA7gdQKvC3jdwOsBXi/w+oDnAc8HXgJ4SeClgJcGXj/wMsALgJcF3gDwBoE3BLxh4I0Ab1R4XKfqnZvhhnOUueK4uO7J34+OZX2TdU3WM1nHZP2SdUvWK1mnZH2SdUnWI1mHZP2RdUfWG1lnZH2RdUXWE1lHZP2QdUPWC1knZH2QdSGqB2OkcdIEaZI0RZomzZBmSXOkedICaZG0RFomrZBWSWukddIGaZO0Rdom7ZB2SXukfdIB6ZB0RDomnZBOndsjFs5j4Zz0+lOpfCaR95P+uZfI5oK0l0rn+gM/8NNB+jIRJJP5IBVksrlsxsv6qWTeL6SzyYJ3M+rFWt79hj+mt5ZXSuYGReZxS5gbFZknLGFuUmSetIS5WZF5yhLmFkXmaUuYWxWZZyxhblNknrWEuV2Rec4S5g5F5nlLmDsVmRcsYe5SZF60hLlbkXnJEuYeReZlS5h7FZlXLGHuU2RetYTZU2Res4TZV2Ret4Q5oci8YQlzUpF50xLmlCLzliXMaUXmbUuY+xWZdyxhzigy71rCHCgy71nCnFVk3reEeUCR+cAS5kFF5kNLmIcUmY8sYR5WZD62hHlEkfnEEuZRReZTS5g11zpTYy4USsnsKq51rsgc9Zawzpx/fRDn4XHOuT209yWmuNZFifYlJ/blIjy+LPG+xBXXypdoXy7FvuTDY/4nKgtfy3XuDld5nwrKbNG4KuUJX4F1vXuNQuHK0S1W0ZtYX/Tm8R96PMy5yYyby6KmMm4i4+YxbhrjZjFuEuPmMG4K42YwbgLj5i9u+uJmL27y4uYuburiZi5u4uLmLW7a4mYtbtLi5qw6cR48czNPo3PTbMnND9wMwA/H+WExPzzlh4n8cI0fNvHDF34YwTfn+WY1f/rwzUy+ucc3u/jmD98M4ZsDfLHMF498McUXF/xlm7988pcx/nIyKvaiQRyPh/PU1+vr3nTrpIj+NpD9L5s0ZFOGbNqQzRiyWUM2Z8jmDdmCIVs0ZEuGbNmQrRiyVUO2ZsjWDdmGIds0ZFuGbNuQ7RiyXUO2Z8j2DdmBITs0ZEeG7NiQnRiyU0N2Zsg+h/PPX99/f9v8EUR+VGOriuZakcsPWu9+w4/WrynN+l6Fc3fUiuOaIs6YyMaUziFaLx7O5c7dESvKop+tLDo/V//8/OJziYPXikZ1ONcIL9rPP7uyrGSlMgAA","debug_symbols":"pdTNjoMgFAXgd2Htgh9B6KtMJo21tCEhaKhOMmn67gMere3CSaOrcxXvF0TkTs72NFyPLlzaGzl83ckpOu/d9ejbpu5dG9Ld+6Mg8+Wxj9amW+RlPHV1dbShJ4cweF+Qn9oP40O3rg5j9nVMo7QgNpxTJvDivM3Vo1i66XorkyWfupmU8gnIzwUlxCwoadYEvi5wyswkcMrVInwOCPoEhF4B/nkHzpiaAcbFhlVIbYsgtglstyAWodw9h41CuQhy9xw2CmoRNH0TvtNV3bj49h8SVabNWxAlx22mFKJCaIQZo6IIhuAIgSgRUCooFZQKSgVFQ9FQNBQNRUPRUDQUDUVD0VAMFAPFQDFQDBQDxUAxSalSaIQZg9HEmJxsygQxlgsxF3l5eC5kLh556aOrT95Op9hlCM3Lodb/dvPIfOx1sW3seYg2L/w4lj7FHw==","file_map":{"50":{"source":"// =============================================================================\n//  Seed Verification Circuit for Cangkulan ZK Card Game\n// =============================================================================\n//\n//  Proves TWO properties simultaneously:\n//    1. blake2s(seed) == seed_hash  (preimage knowledge)\n//    2. seed[0..4] != [0,0,0,0]    (minimum entropy -- first 4 bytes non-zero)\n//\n//  Private input:  seed      (32 bytes) - the player's secret random seed\n//  Public input:   seed_hash (32 bytes) - blake2s(seed), the commitment\n//\n//  This circuit is compiled to ACIR, then proved with UltraHonk (bb.js).\n//  The resulting proof is verified on-chain by the Soroban UltraHonk verifier\n//  contract on the Stellar network.\n//\n//  Security properties:\n//  - Soundness: only someone who knows the actual seed preimage can produce\n//    a valid proof\n//  - Zero-knowledge: the proof reveals nothing about the seed beyond that\n//    its hash matches seed_hash\n//  - Binding: the prover cannot find a different seed that produces the same\n//    hash (collision resistance of blake2s)\n//  - Entropy: trivially weak seeds (leading 4 bytes all zero) are rejected\n//    inside the circuit, so a valid proof guarantees non-trivial entropy\n// =============================================================================\n\nuse std::hash::blake2s;\n\nfn main(seed: [u8; 32], seed_hash: pub [u8; 32]) {\n    // -- 1. Hash preimage constraint --\n    // Compute blake2s hash of the private seed inside the circuit\n    let computed_hash = blake2s(seed);\n\n    // Constrain: computed hash must match the public seed_hash\n    assert(computed_hash == seed_hash, \"seed hash mismatch: blake2s(seed) != seed_hash\");\n\n    // -- 2. Minimum entropy constraint --\n    // Reject seeds whose first 4 bytes are all zero.\n    // This prevents trivially weak seeds like [0; 32] from producing valid\n    // proofs -- the prover must demonstrate the seed has non-trivial entropy\n    // WITHOUT revealing the seed itself.\n    //\n    // We compute the OR of the first 4 bytes; if all are zero the OR is zero.\n    let prefix_or: u8 = seed[0] | seed[1] | seed[2] | seed[3];\n    assert(prefix_or != 0, \"seed entropy too low: first 4 bytes are all zero\");\n}\n\n// =============================================================================\n//  Tests\n// =============================================================================\n\n#[test]\nfn test_valid_seed() {\n    // Test with a known seed and hash pair\n    let seed: [u8; 32] = [\n         1,  2,  3,  4,  5,  6,  7,  8,\n         9, 10, 11, 12, 13, 14, 15, 16,\n        17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32,\n    ];\n    let hash = blake2s(seed);\n    // This should pass - correct preimage + non-zero prefix\n    main(seed, hash);\n}\n\n#[test]\nfn test_seed_with_nonzero_prefix() {\n    // Seed where only byte 0 is non-zero in the first 4 -- should pass\n    let mut seed: [u8; 32] = [0; 32];\n    seed[0] = 0x42;\n    seed[16] = 0xff;\n    let hash = blake2s(seed);\n    main(seed, hash);\n}\n\n#[test]\nfn test_seed_byte3_nonzero() {\n    // Seed where only byte 3 (of the first 4) is non-zero -- should pass\n    let mut seed: [u8; 32] = [0; 32];\n    seed[3] = 1;\n    seed[8] = 0xab;\n    let hash = blake2s(seed);\n    main(seed, hash);\n}\n\n#[test(should_fail_with = \"seed hash mismatch\")]\nfn test_wrong_seed_fails() {\n    let seed: [u8; 32] = [1; 32];\n    let wrong_hash: [u8; 32] = [0; 32]; // wrong hash\n    main(seed, wrong_hash);\n}\n\n#[test(should_fail_with = \"seed entropy too low\")]\nfn test_zero_prefix_fails() {\n    // All-zero seed -- first 4 bytes are zero, must fail\n    let seed: [u8; 32] = [0; 32];\n    let hash = blake2s(seed);\n    main(seed, hash);\n}\n\n#[test(should_fail_with = \"seed entropy too low\")]\nfn test_only_later_bytes_nonzero_fails() {\n    // First 4 bytes zero, rest non-zero -- still fails entropy check\n    let mut seed: [u8; 32] = [0; 32];\n    seed[4] = 0xff;\n    seed[5] = 0xff;\n    seed[31] = 0x01;\n    let hash = blake2s(seed);\n    main(seed, hash);\n}\n","path":"/root/projekku/Stellar-Game-Studio/circuits/seed_verify/src/main.nr"}},"names":["main"],"brillig_names":["directive_invert"]}